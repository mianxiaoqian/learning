<!--
 * @Author: qianqian.zhao
 * @Date: 2020-03-26 09:35:39
 * @LastEditors: qianqian.zhao
 * @LastEditTime: 2020-06-07 21:50:26
 * @Description: 垃圾回收机制
 -->

### V8引擎的内存回收机制
#### 新生代对象
存活时间短，采用复制算法进行垃圾回收
#### 老生代对象
采用标记清除算法进行垃圾回收

### 内存回收方法
垃圾回收工作在javascript引擎内部，负责收走垃圾（不使用的内存），怎么知道一块内存的存储是否还使用，就有几种方法
#### 引用计数
##### 活动对象
##### 非活动对象
当堆内存内的对象的引用次数为0时，会即刻回收内存；但是如果对象相互循环引用，就会导致引用数都不是0，则使用完后都不会被回收，就会造成内存泄漏

* 引用计数方法正在被逐渐替代

#### 标记清除（一个定时运行的任务）
两个阶段：
标记阶段，清除阶段；
标记阶段：深度优先遍历，从根作用域开始，遍历到最后一个对象，如果对象被一层一层引用，则标记上被引用的标记；就表明是一个“活动对象”
注：互相引用的两个对象，无法从根作用域到达，所以不会被打上标记
清除阶段：遍历堆内存，将“非活动对象”进行清除


#### 复制算法？
将内存空间分成两部分，一部分存储，在进行内存回收时，将“活动对象”复制到另一个空间；复制结束后，两部分空间名称对换，就完成了垃圾回收；
疑问:这里的活动对象是如何确定的？

### 内存回收后内存空间不连续的问题
在进行一次标记清除回收后,内存空间会出现不连续的状态。这种内存碎片会对后续的内存分配造成问题,因为很可能出现需要分配一个大对象的情况,这时所有的碎片空间都无法完成此次分配,就会提前触发垃圾回收,而这次回收是不必要的。Mark-Compact 对象在标记为死亡后,在整理的过程中,将活着的对象往一端移动,移动完成后,直接清理掉边界外的内存
